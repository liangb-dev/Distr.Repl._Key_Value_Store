#!/usr/bin/python

import sys
import socket
import time
import threading
import string
import getpass
import argparse

parser = argparse.ArgumentParser(description='example - send messages on message bus')
parser.add_argument('nodeid', metavar='n', type=int, nargs=1, help='Node ID')

args = parser.parse_args()
nodeid = args.nodeid[0]

dict = {}


def hash2node(key):
    h = sum(map(lambda x: int(ord(x)), list(key)))%255
    n = int(h/0x20)
    return n 

def send(pkt, seq, s):
    s.send(pkt)
    seq += 1
    return seq

def mkpkt(To, From, Cmd, Id, Key, Value):
    pkt = "To: %d\nFrom: %d\nCmd: %d\nId: %d\nKey: %d\nValue: %d\n" % (To, From, Cmd, Id, Key, Value)
    return pkt


"""
Returns a pkt as response to recieve packet
"""
def protocolop(cmd, key, nodeid, seq, s):
    n = hash2node(key)
    if (cmd == 'put'):
        # Send 'store' message to each node n, n+1, n+2
        # Use correct ID field 
        for i in range(0, 3):
            pkt = mkpkt(n+i, nodeid, 'store',seq, '', '') 
            seq = send(pkt, seq, s)

        # return 'cmd: ok' to client if get reply from one
        # If all three nodes don't reply (within 1s each), reply 'cmd:fail' to client

    elif (cmd == 'store'):
        # store key/value pair in internal database
        dict[key] = value
        # return 'cmd:ok'

    elif (cmd == 'get'):
        # Send 'fetch' to nodes n, n+1, n+2
        for i in range(0,3):
            pkt = mkpkt(n+i, nodeid, 'fetch', seq, '', '')
            seq = send(pkt, seq, s)
        
        # return 'cmd:ok' if one replies (appropriate 'id', 'key', and 'value'
        # else return 'cmd:fail' 
    elif (cmd == 'fetch'):
        # look up requested key and return it in a 'cmd:ok' message
        # else return 'cmd: fail'
    elif (cmd == 'reload'):
        # send a 'cmd:store' with every key in internal database to send node n
        for key in dict.keys():
            pkt = mkpkt(n, nodeid, 'store', seq, key, dict[key])
            seq = send(pkt, seq, s)
    else:


def receive(s):
    while True:
        dgram = s.recv(4096)
        if not dgram:
            print 'lost connection'
            sys.exit(1)
        print 'received:'
        for line in dgram.split('\n'):
            print ' ', line

if __name__ == '__main__':
    s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    s.bind('\0%s.test-%d' % (getpass.getuser(), nodeid))
    if s.connect_ex('\0%s.bus.%d' % (getpass.getuser(), nodeid)):
        print 'connection error'
        sys.exit(1)

    t = threading.Thread(target = receive, args=[s])
    t.daemon = True
    t.start()

    seq = 0
    while True:
        for i in range(9):
            time.sleep(1)
            pkt = "To: %d\nFrom: %d\nCmd: test\nId: %d\nKey: \nValue: \n" % (i, nodeid, seq)
            s.send(pkt)
            seq += 1

