#!/usr/bin/python

import sys
import socket
import time
import threading
import string
import getpass
import argparse
import Queue
import random

parser = argparse.ArgumentParser(description='example - send messages on message bus')
parser.add_argument('nodeid', metavar='n', type=int, nargs=1, help='Node ID')

args = parser.parse_args()
nodeid = str(args.nodeid[0])

localdict = dict()
cmdarr = []
okarr = []
ackarr = [] 
seq = random.randint(5000,10000)



"""
parsepkt
args: pkt
return: List
description: parses out a packet into List of fields 
"""
def parsepkt(package): 
    pkt = package.split('\n')
    if (pkt[-1] == ''):
        pkt = pkt[:-1]
    pkt = map(lambda x: x.split(': ')[1], pkt)
    return pkt


"""
hash2node
args: key
return: n
description: hashes a key
"""
def hash2node(key):
    h = sum(map(lambda x: int(ord(x)), list(key)))%255
    n = int(h/0x20)
    return n 

"""
mkpkt
args: To, From, Cmd, Id, Key, Value
return: String 
description: Takes input and formats a packet
"""
def mkpkt(To, From, Cmd, Id, Key, Value):
    pkt = "To: %s\nFrom: %s\nCmd: %s\nId: %s\nKey: %s\nValue: %s\n" % (To, From, Cmd, Id, Key, Value)
    return pkt


"""
randsleep
description: random 0.001 precision sleep
"""
def randsleep():
    time.sleep(random.randint(10,100)/10)

"""
putqueue
args: pkt
return: none
description: Puts pkt into either okarr or cmdarr
"""
def putqueue(pkt):
    randsleep()
    
    if (parsepkt(pkt)[2] == 'ok'):
        okarr.append(pkt)
        printpkt(pkt, "okarr new item!")
    else:
        cmdarr.append(pkt)
        printpkt(pkt, "cmdarr new item!")

"""
printpkt
args:
return:
description:
"""
def printpkt(pkt, str1):
    To = parsepkt(pkt)[0]
    From = parsepkt(pkt)[1]
    Cmd = parsepkt(pkt)[2]
    Id = parsepkt(pkt)[3]
    Key = parsepkt(pkt)[4]
    Value = parsepkt(pkt)[5]

    if (len(parsepkt(pkt))> 6):
        Client = parsepkt(pkt)[6]

    print str1 + " To: %s, From: %s, Cmd: %s, Id: %s" % (To, From, Cmd, Id)


"""
processok
args: pkt, client, s
return: none
description: checks if pkt is in ackarr, if it is then send 'cmd:ok' and delete ack entry (including sibling entries)
"""
def processok(s):
    global seq
    global timelimit
    while True:
        if len(okarr) > 0:
            pkt = okarr.pop(0)        
            printpkt(pkt, "okarr item processed!")
            randsleep()    
        
            To = parsepkt(pkt)[0]
            From = parsepkt(pkt)[1]
            Cmd = parsepkt(pkt)[2]
            Id = parsepkt(pkt)[3]
            Key = parsepkt(pkt)[4]
            Value = parsepkt(pkt)[5]
            

            i = 0
            while (i < len(ackarr)):
                for ackpkt in ackarr[i]:                        
                    if Id in parsepkt(ackpkt)[3]:
                        print "FOUND MATCHHHHHHHHH"
                        Client = parsepkt(ackpkt)[6]
                        ClientId = parsepkt(ackpkt)[7]
                        clientok = mkpkt(Client, nodeid, 'ok', ClientId, Key, Value)
                        s.send(clientok)
                        printpkt(clientok, "To Client ")
                        printpkt(ackpkt, "ackarr popped w/ siblings! ")
                        ackarr.pop(i)
                        i -= 1
                        break
                            
                break
            i += 1                
                                 
                     

"""
protocolop
args: pkt, nodeid, s
return: null
description: Performs cmd operations
"""
def protocolop(s):
    global seq
    while True:
        randsleep()
        if len(cmdarr) > 0:
            pkt = cmdarr.pop(0)
            printpkt(pkt, "cmdarr processed!")
    
            To = parsepkt(pkt)[0]
            From = parsepkt(pkt)[1]
            Cmd = parsepkt(pkt)[2]
            Id = parsepkt(pkt)[3]
            Key = parsepkt(pkt)[4]
            Value = parsepkt(pkt)[5]
    
            n = hash2node(Key)    

            tmp = []

            if (Cmd == 'put'):
                # Send 'store' message to each node n, n+1, n+2
                # Use correct ID field 
                for i in range(0, 3):
                    seq += 1
                    pkt = mkpkt(str(n+i), nodeid, 'store', str(seq), Key, Value) 
                    s.send(pkt)
                    tmp.append(pkt + "Client: " + str(From) + "\nId: " + str(Id) + '\nTime: 9')

                # return 'cmd: ok' to client if get reply from one
                # If all three nodes don't reply (within 1s each), reply 'cmd:fail' to client

            elif (Cmd == 'store'):
                localdict[Key] = Value  # store key/value pair in internal database
                s.send(mkpkt(From, nodeid, 'ok', Id, Key, Value)) # return 'cmd:ok'
        

            elif (Cmd == 'get'):
                # Send 'fetch' to nodes n, n+1, n+2
                for i in range(0,3):
                    seq += 1
                    pkt = mkpkt(str(n+i), nodeid, 'fetch', str(seq), Key, Value)
                    s.send(pkt)
                    tmp.append(pkt + 'Client: ' + str(From) + "\nId: " + str(Id) + '\nTime: 9')
        
                # return 'cmd:ok' if one replies (appropriate 'id', 'key', and 'value'
                # else return 'cmd:fail' 
            elif (Cmd == 'fetch'):
                # look up requested key and return it in a 'cmd:ok' message
                if Key in localdict:
                    s.send(mkpkt(From, nodeid, 'ok', Id, Key, localdict[Key]))
                # else return 'cmd: fail'
                else: 
                    s.send(mkpkt(From, nodeid, 'fail', Id, Key, Value))
            elif (Cmd == 'reload'):
                # send a 'cmd:store' with every key in internal database to send node n
                
                for key in localdict.keys():
                    seq += 1
                    pkt = mkpkt(From, nodeid, 'store', str(seq), key, localdict[key]) 
                    s.send(pkt)
                    tmp.append(pkt + 'Client: ' + str(From) + "\nId: " + str(Id) + '\nTime: 9')
                # wait for reply 
            if (len(tmp) > 0):
                print "ackarr sequence cached"
                for p in tmp:
                    printpkt(p, "cache: ")
                ackarr.append(tmp)


def receive(s):
    while True:
        dgram = s.recv(4096)
        if not dgram:
            print 'lost connection'
            sys.exit(1)

        putqueue(dgram) # separates packages into okarr and cmdarr
        """
        print 'received:' 
        for line in dgram.split('\n'):
            print ' ', line
        """

"""
dtimeout
description: function that handles timeout of all cached msgs
"""
def dtimeout():
    # timeout only for ackarr
    global ackarr
    while True:
        i = 0
        while(i < len(ackarr)): # iterate over entire ackarr
            j = 0
            while(j < len(ackarr[i])): # iterate over every array group in ackarr
                pkt = ackarr[i][j]    
                timestamp = int(parsepkt(pkt)[8])
                if (timestamp == 0):
                    ackarr[i].pop(j)
                    j -= 1                
                else: 
                    ackarr[i][j] = pkt[:-1] + str(timestamp-1)
                j += 1

            if (len(ackarr[i]) == 0):   # if group becomes empty 
                ackarr.pop(i)           #   pop group
                i -= 1
            i += 1
                
        time.sleep(0.1)


if __name__ == '__main__':
    s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    s.bind('\0%s.test-%d' % (getpass.getuser(), int(nodeid)))
    if s.connect_ex('\0%s.bus.%d' % (getpass.getuser(), int(nodeid))):
        print 'connection error'
        sys.exit(1)

    # thread for receiving packages & caching into cmdarr or okarr
    t = threading.Thread(target = receive, args=[s])
    t.daemon = True
    t.start()
    
    # thread for specifically sending 'cmd:ok'
    t2 = threading.Thread(target = processok, args=[s])
    t2.daemon = True
    t2.start()

    
    # thread for timeouts
    t3 = threading.Thread(target = dtimeout, args=[])
    t3.daemon = True
    t3.start()
    
    # handle (send) all other cmd packets
    protocolop(s)  
    


    """
    while True:
        for i in range(9):
            time.sleep(1)
            s.send(mkpkt(i, nodeid, 'test', seq, " ", " "))
            seq += 1 
    """
