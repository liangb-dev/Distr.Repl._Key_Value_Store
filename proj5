#!/usr/bin/python

import sys
import socket
import time
import threading
import string
import getpass
import argparse
import Queue
import random

parser = argparse.ArgumentParser(description='example - send messages on message bus')
parser.add_argument('nodeid', metavar='n', type=int, nargs=1, help='Node ID')

args = parser.parse_args()
nodeid = args.nodeid[0]

localdict = dict()
cmdarr = Queue.Queue()
okarr = Queue.Queue()
ackarr = [] 
seq = random.randint(5000,10000)

#TODO: 1s Timeout for cachedict & ackdict



"""
parsepkt
args: pkt
return: List
description: parses out a packet into List of fields 
"""
def parsepkt(package): 
    pkt = package.split('\n')[:6]
    pkt = map(lambda x: x.split(': ')[1], pkt)
    return pkt


"""
hash2node
args: key
return: n
description: hashes a key
"""
def hash2node(key):
    h = sum(map(lambda x: int(ord(x)), list(key)))%255
    n = int(h/0x20)
    return n 

"""
mkpkt
args: To, From, Cmd, Id, Key, Value
return: String 
description: Takes input and formats a packet
"""
def mkpkt(To, From, Cmd, Id, Key, Value):
    pkt = "To: %d\nFrom: %d\nCmd: %d\nId: %d\nKey: %d\nValue: %d\n" % (To, From, Cmd, Id, Key, Value)
    return pkt


"""
putqueue
args: pkt
return: none
description: Puts pkt into either okarr or cmdarr
"""
def putqueue(pkt):
    if (parsepkt(pkt)[2] == 'ok'):
        okarr.put(pkt)
    else:
        cmdarr.put(pkt)


"""
processok
args: pkt, client, s
return: none
description: checks if pkt is in ackarr, if it is then send 'cmd:ok' and delete ack entry (including sibling entries)
"""
def processok(s):
    while True:
        if not okarr.empty():
            pkt = okarr.get()        
    
            To = parsepkt(pkt)[0]
            From = parsepkt(pkt)[1]
            Cmd = parsepkt(pkt)[2]
            Id = parsepkt(pkt)[3]
            Key = parsepkt(pkt)[4]
            Value = parsepkt(pkt)[5]
            Client = pkt[-1:]

            for i in range(0,len(ackarr)):
                if len(ackarr[i]) != 0:
                    for pkt in ackarr[i]:
                        if Id in pkt.split('\n')[3]:
                            seq += 1
                            s.send(mkpkt(Client, nodeid, 'ok', seq, Key, Value))
                            myarr.pop(i)
                     

"""
protocolop
args: pkt, nodeid, s
return: null
description: Performs cmd operations
"""
def protocolop(s):
    while True:
        if not cmdarr.empty():
            pkt = cmdarr.get()
    
            To = parsepkt(pkt)[0]
            From = parsepkt(pkt)[1]
            Cmd = parsepkt(pkt)[2]
            Id = parsepkt(pkt)[3]
            Key = parsepkt(pkt)[4]
            Value = parsepkt(pkt)[5]
    
            n = hash2node(key)    

            tmp = []

            if (cmd == 'put'):
                # Send 'store' message to each node n, n+1, n+2
                # Use correct ID field 
                for i in range(0, 3):
                    seq += 1
                    pkt = mkpkt(n+i, nodeid, 'store',seq, Key, Value) + str(To) 
                    tmp.append(pkt)
                    s.send(pkt)

                # return 'cmd: ok' to client if get reply from one
                # If all three nodes don't reply (within 1s each), reply 'cmd:fail' to client

            elif (cmd == 'store'):
                localdict[Key] = Value  # store key/value pair in internal database
                s.send(mkpkt(From, nodeid, 'ok', Id, Key, Value)) # return 'cmd:ok'
        

            elif (cmd == 'get'):
                # Send 'fetch' to nodes n, n+1, n+2
                for i in range(0,3):
                    seq += 1
                    pkt = mkpkt(n+i, nodeid, 'fetch', seq, Key, Value) + str(To)
                    tmp.append(pkt)
                    s.send(pkt)
        
                # return 'cmd:ok' if one replies (appropriate 'id', 'key', and 'value'
                # else return 'cmd:fail' 
            elif (cmd == 'fetch'):
                # look up requested key and return it in a 'cmd:ok' message
                if Key in local:
                    s.send(mkpkt(From, nodeid, 'ok', Id, Key, localdict[Key]))
                # else return 'cmd: fail'
                else: 
                    s.send(mkpkt(From, nodeid, 'fail', Id, Key, Value))
            elif (cmd == 'reload'):
                # send a 'cmd:store' with every key in internal database to send node n
                for key in localdict.keys():
                    seq += 1
                    pkt = mkpkt(n, nodeid, 'store', seq, key, localdict[key]) + str(To)
                    tmp.append(pkt)
                    s.send(pkt)
                # wait for reply 


            ackarr.append(tmp)


def receive(s):
    while True:
        dgram = s.recv(4096)
        if not dgram:
            print 'lost connection'
            sys.exit(1)

        putqueue(dgram) # separates packages into okarr and cmdarr

if __name__ == '__main__':
    s = socket.socket(socket.AF_UNIX, socket.SOCK_SEQPACKET)
    s.bind('\0%s.test-%d' % (getpass.getuser(), nodeid))
    if s.connect_ex('\0%s.bus.%d' % (getpass.getuser(), nodeid)):
        print 'connection error'
        sys.exit(1)

    # thread for receiving packages & caching into cmdarr or okarr
    t = threading.Thread(target = receive, args=[s])
    t.daemon = True
    t.start()

    # thread for specifically sending 'cmd:ok'
    t = threading.Thread(target = processok, args=[s])
    t.daemon = True
    t.start()

    # handle (send) all other cmd packets
    protocolop(s)   
